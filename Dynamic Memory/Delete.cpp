#include<iostream>
using namespace std;

/*  动态内存的销毁：
*      程序从操作系统动态分配所得的内存空间在使用完后应该释放，交还操作系统，以便操作系统将这片内存空间分配给其他程序使用，避免内存耗尽。
 *  1、流程：
 *      （1）销毁指针所指向对象
 *      （2）释放内存
 *  2、使用方式：
*   （1）delete p:释放动态内存
*   （2）delete []p：释放动态数组
*
*  ！！！！！！动态内存的销毁可能出现的问题！！！！！！！
*  1、动态内存没有被完全销毁：造成内存泄漏
*  2、动态内存被重复销毁
 * 3、使用已经释放的内存
 *  杜绝以上问题，应该坚持使用智能指针！！
 *
 *  tips：
 *      delete只能处理指针所指向的动态内存，或者空指针
 *      释放一块非动态内存，或者相同的指针值释放多次，其行为是未定义的
*/

void deleteTest() {
    int i, *pi1 = &i, *pi2 = nullptr;
    double *pd = new double(33), *pd2 = pd;

    /*
     * tips；delete 指向非动态内存的指针 编译器通常不会报错，这种行为更加危险，因为产生的结果是未定义的，而且不容易定位
     */
    // delete i; //错误，i不是指针
    delete pi1; // 未定义：pi1指向的不是动态内存
    delete pd; //正确：pd指向动态内存
    delete pd2; //未定义：pd2指向的内存，已经被pd释放了
    delete pi2; //正确：释放空指针

    // 动态分配的const对象的销毁
    const int *pci = new const int(1024);
    delete pci;
};

/*
 * delete之后重置指针
 * 1、空悬指针：指向 一块曾经保存数据，现在无效的内存 的指针。
 *            指针被delete后，指针仍保存着（已经释放了的）动态内存的首地址，此时这块动态内存已经无效了。
 * 2、避免空悬指针：如果delete后还需要保留指针，可以将指针赋值nullptr，表示指针不指向任何对象。
 * 3、tips：delete后重置指针只能对被delete的当前指针提供保护，其他指向（被释放内存）的指针仍然是空悬指针
 */
void ResetPtrTest()
{
    int *p(new int(42)); //p指向动态内存
    auto q = p;
    delete p;
    p = nullptr; // 只能保证p不是空悬指针，q因为指向被释放的 相同的内存，所以仍是空悬指针
}
