#Dynamic Memory
* 核心： 动态分配的对象的生命周期与在哪里创建无关，只有被显示释放时，该对象才会被销毁
* 使用：为了安全使用动态内存，通过两个智能指针来管理动态分配的对象
* 内存：
    * 由编译器负责自动创建和销毁的内存：
      1. 静态内存：用来保存局部static对象，类static数据成员，以及定义在任何函数之外的变量。在使用前分配，在程序结束时销毁
      2. 栈内存：用来保存定义在函数内的非static对象。在程序块（花括号）范围内存在
    * 有程序负责创建和销毁的内存：
      1. 堆内存：一块自由分配的内存池。用来储存动态分配的对象。
    
##动态内存与智能指针
* 动态内存管理：
    1. new:在动态内存为对象 **分配空间** ，并返回指向该对象的 **指针**。
    2. delete：接受指向动态对象的 **指针**，销毁对象，释放与之关联的内存
    3. 困难点：忘记释放内存，导致内存泄漏；在内存尚被指针引用时就释放内存，产生引用非法内存的指针 
    
* 动态内存管理方法：
    1. 智能指针定义：是模板。功能与普通指针相同。唯一不同是可以自动释放所指向的对象。
    2. 智能指针分类（定义在头文件memory中）：
        * shared_ptr:多个指针指向同一个对象
        * unique_ptr:一个指针"独占"所指向的对象
        * weak_ptr:弱引用，指向shared_ptr所管理的对象
    
###shared_ptr类
* shared_ptr定义：
  ```c++
  shared_ptr<string> p1;
  ```

* shared_ptr和unique_ptr都支持的操作：
    1. ```shared_ptr<T> unique_ptr<t>```:空智能指针，指向类型为T的对象
       
    2. p:智能指针p作为一个条件判断，如果指向一个对象，则为true
    3. *p:解引用p，获得它指向的对象
    4. p.get():返回p中保存的**指针**，在使用前必须确保指针所指的对象没有被释放
    5. ```swap(p,q) 和 q.swap(p)```:交换p和q中的指针
    
* shared_ptr独有的操作：
    1. ```make_shared<T>(args)``` 返回一个shared_ptr,指向动态分配的类型为T的对象。使用args初始化对象
    2. ```shared_ptr<T>p(q)```p是shared_ptr的拷贝，此操作会递增q中的计数器。q中的指针必须能转化成T*
    3. p = q:p和q都是shared_ptr,所保存的指针必须能相互转化。此操作会递减p的引用计数，递增q的引用计数。如果p的引用计数为0，会将p所指的内存释放
    4. p.use_count():返回与p 共享对象 的智能指针数量（自身也算一个）。
    5. p.unique():p.use_count()为1（说明只有自己指向该对象），返回true，否则返回false
    
* make_shared函数
    1. 使用方法：
    ```c++
    shared_ptr<string> p3 = make_shared<string>(10,'9');
    auto p4 = make_shared<vector<string>>(); // 传参列表为空，表示默认初始化
    ```
  make_shared是构造智能指针，指向类型为T的对象，传入参数列表必须符合类型T的某个初始化列表

    



  
  
       
    
