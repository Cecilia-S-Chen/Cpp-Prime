#include <iostream>
using namespace std;

/*
 * 模版实参的隐式推断：
 *   类型转化：十分有限，只有以下几种：
 *  （1）const转化
 *  （2）数组或函数指针转化：如果形参不是引用类型。数组实参可以转化为指向其首元素的指针。函数实参可以转化为指向该函数的指针。
 *
 *  函数模版提供显示实参：
 *      方式：实例化时显示给定实参
 *      原因：（1）编译器无法推断出模版实参的类型；（2）希望允许用户控制模版实例化
 *      tips：提供显示实参后，模版参数变为普通参数。普通参数的类型转化都可以用了。
 *
 *  当返回值的类型由模版入参决定：
 *      解决方法：使用尾置返回类型
 */

/*
 * typename说明通过作用域访问的是模版类的类型成员
 * decltype用于参数类型推断
 * remove_reference：将元素的引用类型 转化成元素类型
 */
template<typename It>
auto fcn(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    return *beg;
}

/*
 * 从模版参数引用 推断实参
 *  1、模版参数是左值引用T&，只能给其传递左值，实参可以是const类型；
 *  2、模版参数是const左值引用 const T&,可以传递给其左值或者右值；
 *  3、模版参数是右值引用 T&&，根据引用折叠，可以传递给其左值或者右值；
 *
 *  引用折叠：右值可以折叠成左值，左值不能折叠成右值
 *      （1）X& &\X& &&\X&& & 都能折叠成X&
 *      （2）X&& &&折叠成X&&
 *      tips：
 *          * 引用折叠只能应用于间接创建的引用的引用，如类型别名或模版参数；
 *          * 引用折叠是我们可以用左值调用右值引用模版参数的函数
 *      结论：
 *          * 如果一个函数参数是指向模版类型参数的右值引用（如T&&），则它可以被绑定到左值或左值引用；
 *          * 如果一个实参是左值，则推断出的模版实参类型是一个左值引用，且函数参数被实例化为一个左值引用参数
 *      缺点：因为模版类型参数的右值引用，适用于任何类型的实参，这种不确定性会给程序带来风险。
 *      应用场景：
 *          （1）模版转发其实参：可以保留左值实参的所有信息
 *          （2）模版被重载
 */

/*
 * 转发：
 *  1、std::move:move获得一个绑定到左值上的右值引用
 *  2、核心：将一个或多个实参连同类型不变的转发给其他函数
 */

// std::move 定义，把左值引用转化成右值引用
template <typename T>
typename remove_reference<T>::type&& move(T&& t) // 可以向T&&传递左值或者右值
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}
// std::forward 把左值转化成右值引用


// 转发函数
template<typename F, typename T1, typename T2>
void forward1(F f, T1 t1, T2 t2)
{
    f1(t1, t2);
}
// 问题：当f的参数是引用类型时，forward1无法保留引用属性
void f1(int v1, int& v2)
{
    cout << v1 << ", " << v2 <<endl;
}


// 改进转发函数
template <typename F, typename T1, typename T2>
void forward2(F f, T1&& t1, T2&& t2)
{
    f2(t1, t2);
}
// 问题：当f2的入参是右值引用时，forward2不能将左值传递给右值引用
void f2(int&& v1, int& v2)
{
    cout << v1 << ", " << v2 <<endl;
}


// 再改进转发函数
template <typename F, typename T1, typename T2>
void forward3(F f, T1 &&t1, T2 &&t2)
{
    f(forward<T1>(t1), forward<T2>(t2));
}


/*
 * 重载与模版
 *  1、原则：
 *      （1）如果同样好的函数中只有一个是非模版函数，选择此函数；
 *      （2）如果同样好的函数中没有非模版函数，都是模版函数，且其中一个模版比其他模版更特例化，选择此模版；
 *      （3）否则，调用有歧义
 *  2、举例：
 *      （1）T*比const T&更特例化；
 *      （2）非模版比模版更特例化；
 *      （3）非可变模版比可变模版更特例化；
 *  3、重载模版函数与类型转化
 *      当重载模版函数时，为了在多个版本中，匹配我们期望当版本，必须声明所有重载函数。如果不声明，可能通过类型转化选择错误函数，而编译器不会报错，不易定位。
 */
