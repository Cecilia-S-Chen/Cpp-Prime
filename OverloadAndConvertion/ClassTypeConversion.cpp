#include <iostream>
using namespace std;

/*
 * 类类型转化（用户定义的类型转化）：
 * 1. 转化构造函数：将其他类型转化成自身类类型
 * 2. 类型转化运算符：将自身类类型转化成其他类型
 *      定义：operator type() const; // type表示返回值的类型
 *      tips：（1）类型转化运算符没有形式的返回类型，没有入参。
 *            （2）必须定义成类的成员函数
 *            （3）类型转化运算符一般被定义成const成员
 * 3. 显示的类型转化运算符：
 *  因为隐式的类型转化运算符，得到的结果经常违背使用预期。所以通常采用显示的类型转化运算符。
 *  tips：当表达式被用作条件，编译器会将隐式转化，自动变为显示转化。
 *      （1）if\while\do的条件部分
 *      （2）for的条件部分
 *      （3）逻辑非、与、或，运算符的运算对象
 *      （4）条件运算符（？：）的条件表达式
 */
class SmallNum {
public:
    SmallNum(int i = 0) : val(i) {}
    operator int() const { return val;}
    explicit operator double() const {return val;}
private:
    int val;
};

// 编译器一次只能执行一个*用户定义的类型转化*，但是可以同时执行*内置的类型转化*。隐式调用哪个内置类型转化为最优，由编译器决定。
int main1()
{
    SmallNum si = 3.14; // 1.内置类型转化将double； 2.调用构造函数，将int转化成SmallNum
    double d1 = si + 3.14; // 1.SmallNum通过类型转化运算符转化成int；2.通过内置类型转化，将int转化为double
    double d2 = static_cast<double>(si) + 3.14; // 直接显示的将SmallNum转化成double类型
}

/*
 * 避免*二异性*的类型转化：
 * 1、不要为类定义相同的类型转化：例如：通过A的构造函数可以将B类转化成A类；同时可以通过B的类型转化运算符，将B类转化成A类。
 * 2、不要在类中定义两个及以上转化源或转化目标是算数类型的转化。
 * 3. 注意在重载函数中出现的类型转化二异性。例如重载函数的入参属于不同的类型，当这些类型可以通过类型转化相互转化时，可能存在二异性！
 * 4. 注意在重载运算符中出现类型转化二异性。例如类提供转化目标是算数类型的类型转化，也提供重载运算符，则会碰到重载运算符与内置运算符的二异性问题。
 * PS：除了显示向bool类型转化之外，应该尽量避免定义类型转化函数。
 */
